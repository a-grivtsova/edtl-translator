/*
 * generated by Xtext 2.25.0
 */
package su.nsk.iae.edtl.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.service.AbstractElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class EdtlGrammarAccess extends AbstractElementFinder.AbstractGrammarElementFinder {
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.Model");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cWAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cElementsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cElementsStatementParserRuleCall_1_0 = (RuleCall)cElementsAssignment_1.eContents().get(0);
		
		//Model:
		//{w} (elements+=Statement)*;
		@Override public ParserRule getRule() { return rule; }
		
		//{w} (elements+=Statement)*
		public Group getGroup() { return cGroup; }
		
		//{w}
		public Action getWAction_0() { return cWAction_0; }
		
		//(elements+=Statement)*
		public Assignment getElementsAssignment_1() { return cElementsAssignment_1; }
		
		//Statement
		public RuleCall getElementsStatementParserRuleCall_1_0() { return cElementsStatementParserRuleCall_1_0; }
	}
	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.Statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cDeclVarInputParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cDeclVarOutputParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cAbbrParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cMacrosParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cRequirementParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//Statement:
		//    DeclVarInput | DeclVarOutput | Abbr | Macros | Requirement;
		@Override public ParserRule getRule() { return rule; }
		
		//DeclVarInput | DeclVarOutput | Abbr | Macros | Requirement
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//DeclVarInput
		public RuleCall getDeclVarInputParserRuleCall_0() { return cDeclVarInputParserRuleCall_0; }
		
		//DeclVarOutput
		public RuleCall getDeclVarOutputParserRuleCall_1() { return cDeclVarOutputParserRuleCall_1; }
		
		//Abbr
		public RuleCall getAbbrParserRuleCall_2() { return cAbbrParserRuleCall_2; }
		
		//Macros
		public RuleCall getMacrosParserRuleCall_3() { return cMacrosParserRuleCall_3; }
		
		//Requirement
		public RuleCall getRequirementParserRuleCall_4() { return cRequirementParserRuleCall_4; }
	}
	public class VariableTypeNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.VariableTypeName");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cBOOLKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cINTKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//VariableTypeName returns ecore::EString:
		//    'BOOL' | 'INT';
		@Override public ParserRule getRule() { return rule; }
		
		//'BOOL' | 'INT'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'BOOL'
		public Keyword getBOOLKeyword_0() { return cBOOLKeyword_0; }
		
		//'INT'
		public Keyword getINTKeyword_1() { return cINTKeyword_1; }
	}
	public class DeclVarInputElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.DeclVarInput");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cDeclVarInputAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cVAR_INPUTKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cValueAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cValueVarDeclarationParserRuleCall_2_0_0 = (RuleCall)cValueAssignment_2_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Keyword cEND_VARKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//DeclVarInput:
		//    {DeclVarInput}
		//    'VAR_INPUT' (value+=VarDeclaration ';')* 'END_VAR';
		@Override public ParserRule getRule() { return rule; }
		
		//{DeclVarInput}
		//'VAR_INPUT' (value+=VarDeclaration ';')* 'END_VAR'
		public Group getGroup() { return cGroup; }
		
		//{DeclVarInput}
		public Action getDeclVarInputAction_0() { return cDeclVarInputAction_0; }
		
		//'VAR_INPUT'
		public Keyword getVAR_INPUTKeyword_1() { return cVAR_INPUTKeyword_1; }
		
		//(value+=VarDeclaration ';')*
		public Group getGroup_2() { return cGroup_2; }
		
		//value+=VarDeclaration
		public Assignment getValueAssignment_2_0() { return cValueAssignment_2_0; }
		
		//VarDeclaration
		public RuleCall getValueVarDeclarationParserRuleCall_2_0_0() { return cValueVarDeclarationParserRuleCall_2_0_0; }
		
		//';'
		public Keyword getSemicolonKeyword_2_1() { return cSemicolonKeyword_2_1; }
		
		//'END_VAR'
		public Keyword getEND_VARKeyword_3() { return cEND_VARKeyword_3; }
	}
	public class DeclVarOutputElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.DeclVarOutput");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cDeclVarOutputAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cVAR_OUTPUTKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cValueAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cValueVarDeclarationParserRuleCall_2_0_0 = (RuleCall)cValueAssignment_2_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Keyword cEND_VARKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//DeclVarOutput:
		//    {DeclVarOutput}
		//    'VAR_OUTPUT' (value+=VarDeclaration ';')* 'END_VAR';
		@Override public ParserRule getRule() { return rule; }
		
		//{DeclVarOutput}
		//'VAR_OUTPUT' (value+=VarDeclaration ';')* 'END_VAR'
		public Group getGroup() { return cGroup; }
		
		//{DeclVarOutput}
		public Action getDeclVarOutputAction_0() { return cDeclVarOutputAction_0; }
		
		//'VAR_OUTPUT'
		public Keyword getVAR_OUTPUTKeyword_1() { return cVAR_OUTPUTKeyword_1; }
		
		//(value+=VarDeclaration ';')*
		public Group getGroup_2() { return cGroup_2; }
		
		//value+=VarDeclaration
		public Assignment getValueAssignment_2_0() { return cValueAssignment_2_0; }
		
		//VarDeclaration
		public RuleCall getValueVarDeclarationParserRuleCall_2_0_0() { return cValueVarDeclarationParserRuleCall_2_0_0; }
		
		//';'
		public Keyword getSemicolonKeyword_2_1() { return cSemicolonKeyword_2_1; }
		
		//'END_VAR'
		public Keyword getEND_VARKeyword_3() { return cEND_VARKeyword_3; }
	}
	public class VarDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.VarDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVarAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVarVariableParserRuleCall_0_0 = (RuleCall)cVarAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeVariableTypeNameParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		
		//VarDeclaration:
		//    var=Variable ':' type=VariableTypeName;
		@Override public ParserRule getRule() { return rule; }
		
		//var=Variable ':' type=VariableTypeName
		public Group getGroup() { return cGroup; }
		
		//var=Variable
		public Assignment getVarAssignment_0() { return cVarAssignment_0; }
		
		//Variable
		public RuleCall getVarVariableParserRuleCall_0_0() { return cVarVariableParserRuleCall_0_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//type=VariableTypeName
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//VariableTypeName
		public RuleCall getTypeVariableTypeNameParserRuleCall_2_0() { return cTypeVariableTypeNameParserRuleCall_2_0; }
	}
	public class AbbrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.Abbr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cABBRKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueExpressionParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		private final Keyword cEND_ABBRKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Abbr:
		//    'ABBR' name=ID
		//        (value+=Expression)*
		//    'END_ABBR';
		@Override public ParserRule getRule() { return rule; }
		
		//'ABBR' name=ID
		//    (value+=Expression)*
		//'END_ABBR'
		public Group getGroup() { return cGroup; }
		
		//'ABBR'
		public Keyword getABBRKeyword_0() { return cABBRKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//(value+=Expression)*
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }
		
		//Expression
		public RuleCall getValueExpressionParserRuleCall_2_0() { return cValueExpressionParserRuleCall_2_0; }
		
		//'END_ABBR'
		public Keyword getEND_ABBRKeyword_3() { return cEND_ABBRKeyword_3; }
	}
	public class MacrosElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.Macros");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cMACROSKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cArgsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cArgsVarListParserRuleCall_3_0 = (RuleCall)cArgsAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cValueAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cValueExpressionParserRuleCall_5_0 = (RuleCall)cValueAssignment_5.eContents().get(0);
		private final Keyword cEND_MACROSKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//Macros:
		//    'MACROS' name=ID '(' (args=VarList)? ')'
		//        (value+=Expression)*
		//    'END_MACROS';
		@Override public ParserRule getRule() { return rule; }
		
		//'MACROS' name=ID '(' (args=VarList)? ')'
		//    (value+=Expression)*
		//'END_MACROS'
		public Group getGroup() { return cGroup; }
		
		//'MACROS'
		public Keyword getMACROSKeyword_0() { return cMACROSKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//(args=VarList)?
		public Assignment getArgsAssignment_3() { return cArgsAssignment_3; }
		
		//VarList
		public RuleCall getArgsVarListParserRuleCall_3_0() { return cArgsVarListParserRuleCall_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
		
		//(value+=Expression)*
		public Assignment getValueAssignment_5() { return cValueAssignment_5; }
		
		//Expression
		public RuleCall getValueExpressionParserRuleCall_5_0() { return cValueExpressionParserRuleCall_5_0; }
		
		//'END_MACROS'
		public Keyword getEND_MACROSKeyword_6() { return cEND_MACROSKeyword_6; }
	}
	public class VarListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.VarList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVarsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVarsVariableParserRuleCall_0_0 = (RuleCall)cVarsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cVarsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cVarsVariableParserRuleCall_1_1_0 = (RuleCall)cVarsAssignment_1_1.eContents().get(0);
		
		//VarList:
		//    vars+=Variable (',' vars+=Variable)*;
		@Override public ParserRule getRule() { return rule; }
		
		//vars+=Variable (',' vars+=Variable)*
		public Group getGroup() { return cGroup; }
		
		//vars+=Variable
		public Assignment getVarsAssignment_0() { return cVarsAssignment_0; }
		
		//Variable
		public RuleCall getVarsVariableParserRuleCall_0_0() { return cVarsVariableParserRuleCall_0_0; }
		
		//(',' vars+=Variable)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//vars+=Variable
		public Assignment getVarsAssignment_1_1() { return cVarsAssignment_1_1; }
		
		//Variable
		public RuleCall getVarsVariableParserRuleCall_1_1_0() { return cVarsVariableParserRuleCall_1_1_0; }
	}
	public class RequirementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.Requirement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cREQKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cAttributeAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cAttributeAttributeParserRuleCall_2_0_0 = (RuleCall)cAttributeAssignment_2_0.eContents().get(0);
		private final RuleCall cDECL_SYMBTerminalRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final Assignment cValueAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cValueExpressionParserRuleCall_2_2_0 = (RuleCall)cValueAssignment_2_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_2_3 = (Keyword)cGroup_2.eContents().get(3);
		private final Keyword cEND_REQKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Requirement:
		//    'REQ' name=ID
		//        (
		//            attribute+=Attribute  DECL_SYMB  value+=Expression ';'
		//        )*
		//    'END_REQ';
		@Override public ParserRule getRule() { return rule; }
		
		//'REQ' name=ID
		//    (
		//        attribute+=Attribute  DECL_SYMB  value+=Expression ';'
		//    )*
		//'END_REQ'
		public Group getGroup() { return cGroup; }
		
		//'REQ'
		public Keyword getREQKeyword_0() { return cREQKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//(
		//    attribute+=Attribute  DECL_SYMB  value+=Expression ';'
		//)*
		public Group getGroup_2() { return cGroup_2; }
		
		//attribute+=Attribute
		public Assignment getAttributeAssignment_2_0() { return cAttributeAssignment_2_0; }
		
		//Attribute
		public RuleCall getAttributeAttributeParserRuleCall_2_0_0() { return cAttributeAttributeParserRuleCall_2_0_0; }
		
		//DECL_SYMB
		public RuleCall getDECL_SYMBTerminalRuleCall_2_1() { return cDECL_SYMBTerminalRuleCall_2_1; }
		
		//value+=Expression
		public Assignment getValueAssignment_2_2() { return cValueAssignment_2_2; }
		
		//Expression
		public RuleCall getValueExpressionParserRuleCall_2_2_0() { return cValueExpressionParserRuleCall_2_2_0; }
		
		//';'
		public Keyword getSemicolonKeyword_2_3() { return cSemicolonKeyword_2_3; }
		
		//'END_REQ'
		public Keyword getEND_REQKeyword_3() { return cEND_REQKeyword_3; }
	}
	public class AttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.Attribute");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cTRIGGERKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cINVKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cFINALKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cDELAYKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cREACTIONKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cRELEASEKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		
		//Attribute returns ecore::EString:
		//     'TRIGGER' | 'INV' | 'FINAL' | 'DELAY' | 'REACTION' | 'RELEASE';
		@Override public ParserRule getRule() { return rule; }
		
		//'TRIGGER' | 'INV' | 'FINAL' | 'DELAY' | 'REACTION' | 'RELEASE'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'TRIGGER'
		public Keyword getTRIGGERKeyword_0() { return cTRIGGERKeyword_0; }
		
		//'INV'
		public Keyword getINVKeyword_1() { return cINVKeyword_1; }
		
		//'FINAL'
		public Keyword getFINALKeyword_2() { return cFINALKeyword_2; }
		
		//'DELAY'
		public Keyword getDELAYKeyword_3() { return cDELAYKeyword_3; }
		
		//'REACTION'
		public Keyword getREACTIONKeyword_4() { return cREACTIONKeyword_4; }
		
		//'RELEASE'
		public Keyword getRELEASEKeyword_5() { return cRELEASEKeyword_5; }
	}
	public class VariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.Variable");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//Variable:
		//    name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.Expression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cXorExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOrOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOrOpOR_OPERATORTerminalRuleCall_1_1_0 = (RuleCall)cOrOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightXorExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Expression:
		//    XorExpression ({Expression.left=current} orOp=OR_OPERATOR right=XorExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//XorExpression ({Expression.left=current} orOp=OR_OPERATOR right=XorExpression)*
		public Group getGroup() { return cGroup; }
		
		//XorExpression
		public RuleCall getXorExpressionParserRuleCall_0() { return cXorExpressionParserRuleCall_0; }
		
		//({Expression.left=current} orOp=OR_OPERATOR right=XorExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Expression.left=current}
		public Action getExpressionLeftAction_1_0() { return cExpressionLeftAction_1_0; }
		
		//orOp=OR_OPERATOR
		public Assignment getOrOpAssignment_1_1() { return cOrOpAssignment_1_1; }
		
		//OR_OPERATOR
		public RuleCall getOrOpOR_OPERATORTerminalRuleCall_1_1_0() { return cOrOpOR_OPERATORTerminalRuleCall_1_1_0; }
		
		//right=XorExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//XorExpression
		public RuleCall getRightXorExpressionParserRuleCall_1_2_0() { return cRightXorExpressionParserRuleCall_1_2_0; }
	}
	public class XorExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.XorExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cXorExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final RuleCall cXOR_OPERATORParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAndExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//XorExpression:
		//    AndExpression ({XorExpression.left=current} XOR_OPERATOR right=AndExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//AndExpression ({XorExpression.left=current} XOR_OPERATOR right=AndExpression)*
		public Group getGroup() { return cGroup; }
		
		//AndExpression
		public RuleCall getAndExpressionParserRuleCall_0() { return cAndExpressionParserRuleCall_0; }
		
		//({XorExpression.left=current} XOR_OPERATOR right=AndExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{XorExpression.left=current}
		public Action getXorExpressionLeftAction_1_0() { return cXorExpressionLeftAction_1_0; }
		
		//XOR_OPERATOR
		public RuleCall getXOR_OPERATORParserRuleCall_1_1() { return cXOR_OPERATORParserRuleCall_1_1; }
		
		//right=AndExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//AndExpression
		public RuleCall getRightAndExpressionParserRuleCall_1_2_0() { return cRightAndExpressionParserRuleCall_1_2_0; }
	}
	public class XOR_OPERATORElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.XOR_OPERATOR");
		private final Keyword cXORKeyword = (Keyword)rule.eContents().get(1);
		
		//XOR_OPERATOR:
		//    'XOR';
		@Override public ParserRule getRule() { return rule; }
		
		//'XOR'
		public Keyword getXORKeyword() { return cXORKeyword; }
	}
	public class AndExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.AndExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cCompExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cAndOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cAndOpAND_OPERATORParserRuleCall_1_1_0 = (RuleCall)cAndOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightCompExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//AndExpression:
		//    CompExpression ({AndExpression.left=current} andOp=AND_OPERATOR right=CompExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//CompExpression ({AndExpression.left=current} andOp=AND_OPERATOR right=CompExpression)*
		public Group getGroup() { return cGroup; }
		
		//CompExpression
		public RuleCall getCompExpressionParserRuleCall_0() { return cCompExpressionParserRuleCall_0; }
		
		//({AndExpression.left=current} andOp=AND_OPERATOR right=CompExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{AndExpression.left=current}
		public Action getAndExpressionLeftAction_1_0() { return cAndExpressionLeftAction_1_0; }
		
		//andOp=AND_OPERATOR
		public Assignment getAndOpAssignment_1_1() { return cAndOpAssignment_1_1; }
		
		//AND_OPERATOR
		public RuleCall getAndOpAND_OPERATORParserRuleCall_1_1_0() { return cAndOpAND_OPERATORParserRuleCall_1_1_0; }
		
		//right=CompExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//CompExpression
		public RuleCall getRightCompExpressionParserRuleCall_1_2_0() { return cRightCompExpressionParserRuleCall_1_2_0; }
	}
	public class AND_OPERATORElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.AND_OPERATOR");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cAmpersandAmpersandKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cANDKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//AND_OPERATOR:
		//    '&&' | 'AND';
		@Override public ParserRule getRule() { return rule; }
		
		//'&&' | 'AND'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'&&'
		public Keyword getAmpersandAmpersandKeyword_0() { return cAmpersandAmpersandKeyword_0; }
		
		//'AND'
		public Keyword getANDKeyword_1() { return cANDKeyword_1; }
	}
	public class CompExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.CompExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cEquExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cCompExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cCompOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cCompOpCompOperatorEnumRuleCall_1_1_0 = (RuleCall)cCompOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAndExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//CompExpression:
		//    EquExpression ({CompExpression.left=current} compOp=CompOperator right=AndExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//EquExpression ({CompExpression.left=current} compOp=CompOperator right=AndExpression)*
		public Group getGroup() { return cGroup; }
		
		//EquExpression
		public RuleCall getEquExpressionParserRuleCall_0() { return cEquExpressionParserRuleCall_0; }
		
		//({CompExpression.left=current} compOp=CompOperator right=AndExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{CompExpression.left=current}
		public Action getCompExpressionLeftAction_1_0() { return cCompExpressionLeftAction_1_0; }
		
		//compOp=CompOperator
		public Assignment getCompOpAssignment_1_1() { return cCompOpAssignment_1_1; }
		
		//CompOperator
		public RuleCall getCompOpCompOperatorEnumRuleCall_1_1_0() { return cCompOpCompOperatorEnumRuleCall_1_1_0; }
		
		//right=AndExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//AndExpression
		public RuleCall getRightAndExpressionParserRuleCall_1_2_0() { return cRightAndExpressionParserRuleCall_1_2_0; }
	}
	public class EquExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.EquExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUnExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cEquExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cEquOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cEquOpEquOperatorEnumRuleCall_1_1_0 = (RuleCall)cEquOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightUnExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//EquExpression:
		//    UnExpression ({EquExpression.left=current} equOp=EquOperator right=UnExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//UnExpression ({EquExpression.left=current} equOp=EquOperator right=UnExpression)*
		public Group getGroup() { return cGroup; }
		
		//UnExpression
		public RuleCall getUnExpressionParserRuleCall_0() { return cUnExpressionParserRuleCall_0; }
		
		//({EquExpression.left=current} equOp=EquOperator right=UnExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{EquExpression.left=current}
		public Action getEquExpressionLeftAction_1_0() { return cEquExpressionLeftAction_1_0; }
		
		//equOp=EquOperator
		public Assignment getEquOpAssignment_1_1() { return cEquOpAssignment_1_1; }
		
		//EquOperator
		public RuleCall getEquOpEquOperatorEnumRuleCall_1_1_0() { return cEquOpEquOperatorEnumRuleCall_1_1_0; }
		
		//right=UnExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//UnExpression
		public RuleCall getRightUnExpressionParserRuleCall_1_2_0() { return cRightUnExpressionParserRuleCall_1_2_0; }
	}
	public class UnOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.UnOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNotOperatorParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Keyword cFEKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cREKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cHIGHKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cLOWKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		
		//UnOperator returns ecore::EString:
		//    NotOperator | 'FE' | 'RE' | 'HIGH' | 'LOW' ;
		@Override public ParserRule getRule() { return rule; }
		
		//NotOperator | 'FE' | 'RE' | 'HIGH' | 'LOW'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//NotOperator
		public RuleCall getNotOperatorParserRuleCall_0() { return cNotOperatorParserRuleCall_0; }
		
		//'FE'
		public Keyword getFEKeyword_1() { return cFEKeyword_1; }
		
		//'RE'
		public Keyword getREKeyword_2() { return cREKeyword_2; }
		
		//'HIGH'
		public Keyword getHIGHKeyword_3() { return cHIGHKeyword_3; }
		
		//'LOW'
		public Keyword getLOWKeyword_4() { return cLOWKeyword_4; }
	}
	public class NotOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.NotOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cNOTKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cExclamationMarkKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//NotOperator:
		//    'NOT' | '!';
		@Override public ParserRule getRule() { return rule; }
		
		//'NOT' | '!'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'NOT'
		public Keyword getNOTKeyword_0() { return cNOTKeyword_0; }
		
		//'!'
		public Keyword getExclamationMarkKeyword_1() { return cExclamationMarkKeyword_1; }
	}
	public class UnExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.UnExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPrimaryExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cUnOpAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cUnOpUnOperatorParserRuleCall_1_0_0 = (RuleCall)cUnOpAssignment_1_0.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightPrimaryExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//UnExpression:
		//    PrimaryExpression | unOp=UnOperator right=PrimaryExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//PrimaryExpression | unOp=UnOperator right=PrimaryExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//PrimaryExpression
		public RuleCall getPrimaryExpressionParserRuleCall_0() { return cPrimaryExpressionParserRuleCall_0; }
		
		//unOp=UnOperator right=PrimaryExpression
		public Group getGroup_1() { return cGroup_1; }
		
		//unOp=UnOperator
		public Assignment getUnOpAssignment_1_0() { return cUnOpAssignment_1_0; }
		
		//UnOperator
		public RuleCall getUnOpUnOperatorParserRuleCall_1_0_0() { return cUnOpUnOperatorParserRuleCall_1_0_0; }
		
		//right=PrimaryExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//PrimaryExpression
		public RuleCall getRightPrimaryExpressionParserRuleCall_1_1_0() { return cRightPrimaryExpressionParserRuleCall_1_1_0; }
	}
	public class TauExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.TauExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTAUKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTimeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTimeTimeLiteralParserRuleCall_2_0 = (RuleCall)cTimeAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//TauExpression:
		//    'TAU' '(' (time=TimeLiteral) ')';
		@Override public ParserRule getRule() { return rule; }
		
		//'TAU' '(' (time=TimeLiteral) ')'
		public Group getGroup() { return cGroup; }
		
		//'TAU'
		public Keyword getTAUKeyword_0() { return cTAUKeyword_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//(time=TimeLiteral)
		public Assignment getTimeAssignment_2() { return cTimeAssignment_2; }
		
		//TimeLiteral
		public RuleCall getTimeTimeLiteralParserRuleCall_2_0() { return cTimeTimeLiteralParserRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class TimeLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.TimeLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cTIME_PREF_LITERALParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cIntervalAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cIntervalINTERVALTerminalRuleCall_1_0 = (RuleCall)cIntervalAssignment_1.eContents().get(0);
		
		// // | time=Abbr...
		//TimeLiteral:
		//     TIME_PREF_LITERAL interval=INTERVAL;
		@Override public ParserRule getRule() { return rule; }
		
		//TIME_PREF_LITERAL interval=INTERVAL
		public Group getGroup() { return cGroup; }
		
		//TIME_PREF_LITERAL
		public RuleCall getTIME_PREF_LITERALParserRuleCall_0() { return cTIME_PREF_LITERALParserRuleCall_0; }
		
		//interval=INTERVAL
		public Assignment getIntervalAssignment_1() { return cIntervalAssignment_1; }
		
		//INTERVAL
		public RuleCall getIntervalINTERVALTerminalRuleCall_1_0() { return cIntervalINTERVALTerminalRuleCall_1_0; }
	}
	public class TIME_PREF_LITERALElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.TIME_PREF_LITERAL");
		private final Keyword cTKeyword = (Keyword)rule.eContents().get(1);
		
		//TIME_PREF_LITERAL returns ecore::EString:
		//    '#T';
		@Override public ParserRule getRule() { return rule; }
		
		//'#T'
		public Keyword getTKeyword() { return cTKeyword; }
	}
	public class PrimaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.PrimaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cConstAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cConstINTEGERTerminalRuleCall_0_0 = (RuleCall)cConstAssignment_0.eContents().get(0);
		private final Assignment cVarAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final CrossReference cVarCrossVarAbbrCrossReference_1_0 = (CrossReference)cVarAssignment_1.eContents().get(0);
		private final RuleCall cVarCrossVarAbbrIDTerminalRuleCall_1_0_1 = (RuleCall)cVarCrossVarAbbrCrossReference_1_0.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Assignment cMacrosAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final CrossReference cMacrosMacrosCrossReference_2_0_0 = (CrossReference)cMacrosAssignment_2_0.eContents().get(0);
		private final RuleCall cMacrosMacrosIDTerminalRuleCall_2_0_0_1 = (RuleCall)cMacrosMacrosCrossReference_2_0_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Assignment cArgsAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cArgsParamAssignmentElementsParserRuleCall_2_2_0 = (RuleCall)cArgsAssignment_2_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_3 = (Keyword)cGroup_2.eContents().get(3);
		private final Assignment cTauAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cTauTauExpressionParserRuleCall_3_0 = (RuleCall)cTauAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Keyword cLeftParenthesisKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cNestExprAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cNestExprExpressionParserRuleCall_4_1_0 = (RuleCall)cNestExprAssignment_4_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4_2 = (Keyword)cGroup_4.eContents().get(2);
		
		//PrimaryExpression:
		//    const=INTEGER | var=[CrossVarAbbr] | macros=[Macros]'(' (args=ParamAssignmentElements)? ')'| tau=TauExpression | '(' nestExpr=Expression ')';
		@Override public ParserRule getRule() { return rule; }
		
		//const=INTEGER | var=[CrossVarAbbr] | macros=[Macros]'(' (args=ParamAssignmentElements)? ')'| tau=TauExpression | '(' nestExpr=Expression ')'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//const=INTEGER
		public Assignment getConstAssignment_0() { return cConstAssignment_0; }
		
		//INTEGER
		public RuleCall getConstINTEGERTerminalRuleCall_0_0() { return cConstINTEGERTerminalRuleCall_0_0; }
		
		//var=[CrossVarAbbr]
		public Assignment getVarAssignment_1() { return cVarAssignment_1; }
		
		//[CrossVarAbbr]
		public CrossReference getVarCrossVarAbbrCrossReference_1_0() { return cVarCrossVarAbbrCrossReference_1_0; }
		
		//ID
		public RuleCall getVarCrossVarAbbrIDTerminalRuleCall_1_0_1() { return cVarCrossVarAbbrIDTerminalRuleCall_1_0_1; }
		
		//macros=[Macros]'(' (args=ParamAssignmentElements)? ')'
		public Group getGroup_2() { return cGroup_2; }
		
		//macros=[Macros]
		public Assignment getMacrosAssignment_2_0() { return cMacrosAssignment_2_0; }
		
		//[Macros]
		public CrossReference getMacrosMacrosCrossReference_2_0_0() { return cMacrosMacrosCrossReference_2_0_0; }
		
		//ID
		public RuleCall getMacrosMacrosIDTerminalRuleCall_2_0_0_1() { return cMacrosMacrosIDTerminalRuleCall_2_0_0_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2_1() { return cLeftParenthesisKeyword_2_1; }
		
		//(args=ParamAssignmentElements)?
		public Assignment getArgsAssignment_2_2() { return cArgsAssignment_2_2; }
		
		//ParamAssignmentElements
		public RuleCall getArgsParamAssignmentElementsParserRuleCall_2_2_0() { return cArgsParamAssignmentElementsParserRuleCall_2_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2_3() { return cRightParenthesisKeyword_2_3; }
		
		//tau=TauExpression
		public Assignment getTauAssignment_3() { return cTauAssignment_3; }
		
		//TauExpression
		public RuleCall getTauTauExpressionParserRuleCall_3_0() { return cTauTauExpressionParserRuleCall_3_0; }
		
		//'(' nestExpr=Expression ')'
		public Group getGroup_4() { return cGroup_4; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_4_0() { return cLeftParenthesisKeyword_4_0; }
		
		//nestExpr=Expression
		public Assignment getNestExprAssignment_4_1() { return cNestExprAssignment_4_1; }
		
		//Expression
		public RuleCall getNestExprExpressionParserRuleCall_4_1_0() { return cNestExprExpressionParserRuleCall_4_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4_2() { return cRightParenthesisKeyword_4_2; }
	}
	public class ParamAssignmentElementsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.ParamAssignmentElements");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cElementsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cElementsVariableCrossReference_0_0 = (CrossReference)cElementsAssignment_0.eContents().get(0);
		private final RuleCall cElementsVariableIDTerminalRuleCall_0_0_1 = (RuleCall)cElementsVariableCrossReference_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cElementsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final CrossReference cElementsVariableCrossReference_1_1_0 = (CrossReference)cElementsAssignment_1_1.eContents().get(0);
		private final RuleCall cElementsVariableIDTerminalRuleCall_1_1_0_1 = (RuleCall)cElementsVariableCrossReference_1_1_0.eContents().get(1);
		
		//ParamAssignmentElements:
		//    elements+=[Variable] (',' elements+=[Variable])*;
		@Override public ParserRule getRule() { return rule; }
		
		//elements+=[Variable] (',' elements+=[Variable])*
		public Group getGroup() { return cGroup; }
		
		//elements+=[Variable]
		public Assignment getElementsAssignment_0() { return cElementsAssignment_0; }
		
		//[Variable]
		public CrossReference getElementsVariableCrossReference_0_0() { return cElementsVariableCrossReference_0_0; }
		
		//ID
		public RuleCall getElementsVariableIDTerminalRuleCall_0_0_1() { return cElementsVariableIDTerminalRuleCall_0_0_1; }
		
		//(',' elements+=[Variable])*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//elements+=[Variable]
		public Assignment getElementsAssignment_1_1() { return cElementsAssignment_1_1; }
		
		//[Variable]
		public CrossReference getElementsVariableCrossReference_1_1_0() { return cElementsVariableCrossReference_1_1_0; }
		
		//ID
		public RuleCall getElementsVariableIDTerminalRuleCall_1_1_0_1() { return cElementsVariableIDTerminalRuleCall_1_1_0_1; }
	}
	public class CrossVarAbbrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.CrossVarAbbr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVariableParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAbbrParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		////ParamAssignment:
		////    variable=[Variable] assig=AssignmentType value=Expression;
		//CrossVarAbbr:
		//    Variable | Abbr;
		@Override public ParserRule getRule() { return rule; }
		
		//Variable | Abbr
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Variable
		public RuleCall getVariableParserRuleCall_0() { return cVariableParserRuleCall_0; }
		
		//Abbr
		public RuleCall getAbbrParserRuleCall_1() { return cAbbrParserRuleCall_1; }
	}
	
	public class EquOperatorElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.EquOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cEQUALEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cEQUALEqualsSignEqualsSignKeyword_0_0 = (Keyword)cEQUALEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cNOT_EQUALEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cNOT_EQUALLessThanSignGreaterThanSignKeyword_1_0 = (Keyword)cNOT_EQUALEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum EquOperator:
		//    EQUAL='==' | NOT_EQUAL='<>';
		public EnumRule getRule() { return rule; }
		
		//EQUAL='==' | NOT_EQUAL='<>'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//EQUAL='=='
		public EnumLiteralDeclaration getEQUALEnumLiteralDeclaration_0() { return cEQUALEnumLiteralDeclaration_0; }
		
		//'=='
		public Keyword getEQUALEqualsSignEqualsSignKeyword_0_0() { return cEQUALEqualsSignEqualsSignKeyword_0_0; }
		
		//NOT_EQUAL='<>'
		public EnumLiteralDeclaration getNOT_EQUALEnumLiteralDeclaration_1() { return cNOT_EQUALEnumLiteralDeclaration_1; }
		
		//'<>'
		public Keyword getNOT_EQUALLessThanSignGreaterThanSignKeyword_1_0() { return cNOT_EQUALLessThanSignGreaterThanSignKeyword_1_0; }
	}
	public class CompOperatorElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.CompOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cLESSEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cLESSLessThanSignKeyword_0_0 = (Keyword)cLESSEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cGREATEREnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cGREATERGreaterThanSignKeyword_1_0 = (Keyword)cGREATEREnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cLESS_EQUEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cLESS_EQULessThanSignEqualsSignKeyword_2_0 = (Keyword)cLESS_EQUEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cGREATER_EQUEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cGREATER_EQUGreaterThanSignEqualsSignKeyword_3_0 = (Keyword)cGREATER_EQUEnumLiteralDeclaration_3.eContents().get(0);
		
		//enum CompOperator:
		//    LESS='<' | GREATER='>' | LESS_EQU='<=' | GREATER_EQU='>=';
		public EnumRule getRule() { return rule; }
		
		//LESS='<' | GREATER='>' | LESS_EQU='<=' | GREATER_EQU='>='
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//LESS='<'
		public EnumLiteralDeclaration getLESSEnumLiteralDeclaration_0() { return cLESSEnumLiteralDeclaration_0; }
		
		//'<'
		public Keyword getLESSLessThanSignKeyword_0_0() { return cLESSLessThanSignKeyword_0_0; }
		
		//GREATER='>'
		public EnumLiteralDeclaration getGREATEREnumLiteralDeclaration_1() { return cGREATEREnumLiteralDeclaration_1; }
		
		//'>'
		public Keyword getGREATERGreaterThanSignKeyword_1_0() { return cGREATERGreaterThanSignKeyword_1_0; }
		
		//LESS_EQU='<='
		public EnumLiteralDeclaration getLESS_EQUEnumLiteralDeclaration_2() { return cLESS_EQUEnumLiteralDeclaration_2; }
		
		//'<='
		public Keyword getLESS_EQULessThanSignEqualsSignKeyword_2_0() { return cLESS_EQULessThanSignEqualsSignKeyword_2_0; }
		
		//GREATER_EQU='>='
		public EnumLiteralDeclaration getGREATER_EQUEnumLiteralDeclaration_3() { return cGREATER_EQUEnumLiteralDeclaration_3; }
		
		//'>='
		public Keyword getGREATER_EQUGreaterThanSignEqualsSignKeyword_3_0() { return cGREATER_EQUGreaterThanSignEqualsSignKeyword_3_0; }
	}
	
	private final ModelElements pModel;
	private final StatementElements pStatement;
	private final VariableTypeNameElements pVariableTypeName;
	private final DeclVarInputElements pDeclVarInput;
	private final DeclVarOutputElements pDeclVarOutput;
	private final VarDeclarationElements pVarDeclaration;
	private final AbbrElements pAbbr;
	private final MacrosElements pMacros;
	private final VarListElements pVarList;
	private final RequirementElements pRequirement;
	private final AttributeElements pAttribute;
	private final TerminalRule tDECL_SYMB;
	private final VariableElements pVariable;
	private final ExpressionElements pExpression;
	private final TerminalRule tOR_OPERATOR;
	private final XorExpressionElements pXorExpression;
	private final XOR_OPERATORElements pXOR_OPERATOR;
	private final AndExpressionElements pAndExpression;
	private final AND_OPERATORElements pAND_OPERATOR;
	private final CompExpressionElements pCompExpression;
	private final EquExpressionElements pEquExpression;
	private final EquOperatorElements eEquOperator;
	private final CompOperatorElements eCompOperator;
	private final UnOperatorElements pUnOperator;
	private final NotOperatorElements pNotOperator;
	private final UnExpressionElements pUnExpression;
	private final TauExpressionElements pTauExpression;
	private final TimeLiteralElements pTimeLiteral;
	private final TIME_PREF_LITERALElements pTIME_PREF_LITERAL;
	private final TerminalRule tINTERVAL;
	private final PrimaryExpressionElements pPrimaryExpression;
	private final ParamAssignmentElementsElements pParamAssignmentElements;
	private final CrossVarAbbrElements pCrossVarAbbr;
	private final TerminalRule tINTEGER;
	private final TerminalRule tLETTER;
	private final TerminalRule tBIT;
	private final TerminalRule tOCTAL_DIGIT;
	private final TerminalRule tDIGIT;
	private final TerminalRule tHEX_DIGIT;
	private final TerminalRule tID;
	private final TerminalRule tML_COMMENT;
	private final TerminalRule tSL_COMMENT;
	private final TerminalRule tWS;
	
	private final Grammar grammar;

	@Inject
	public EdtlGrammarAccess(GrammarProvider grammarProvider) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.pModel = new ModelElements();
		this.pStatement = new StatementElements();
		this.pVariableTypeName = new VariableTypeNameElements();
		this.pDeclVarInput = new DeclVarInputElements();
		this.pDeclVarOutput = new DeclVarOutputElements();
		this.pVarDeclaration = new VarDeclarationElements();
		this.pAbbr = new AbbrElements();
		this.pMacros = new MacrosElements();
		this.pVarList = new VarListElements();
		this.pRequirement = new RequirementElements();
		this.pAttribute = new AttributeElements();
		this.tDECL_SYMB = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.DECL_SYMB");
		this.pVariable = new VariableElements();
		this.pExpression = new ExpressionElements();
		this.tOR_OPERATOR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.OR_OPERATOR");
		this.pXorExpression = new XorExpressionElements();
		this.pXOR_OPERATOR = new XOR_OPERATORElements();
		this.pAndExpression = new AndExpressionElements();
		this.pAND_OPERATOR = new AND_OPERATORElements();
		this.pCompExpression = new CompExpressionElements();
		this.pEquExpression = new EquExpressionElements();
		this.eEquOperator = new EquOperatorElements();
		this.eCompOperator = new CompOperatorElements();
		this.pUnOperator = new UnOperatorElements();
		this.pNotOperator = new NotOperatorElements();
		this.pUnExpression = new UnExpressionElements();
		this.pTauExpression = new TauExpressionElements();
		this.pTimeLiteral = new TimeLiteralElements();
		this.pTIME_PREF_LITERAL = new TIME_PREF_LITERALElements();
		this.tINTERVAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.INTERVAL");
		this.pPrimaryExpression = new PrimaryExpressionElements();
		this.pParamAssignmentElements = new ParamAssignmentElementsElements();
		this.pCrossVarAbbr = new CrossVarAbbrElements();
		this.tINTEGER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.INTEGER");
		this.tLETTER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.LETTER");
		this.tBIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.BIT");
		this.tOCTAL_DIGIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.OCTAL_DIGIT");
		this.tDIGIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.DIGIT");
		this.tHEX_DIGIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.HEX_DIGIT");
		this.tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.ID");
		this.tML_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.ML_COMMENT");
		this.tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.SL_COMMENT");
		this.tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "su.nsk.iae.edtl.Edtl.WS");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("su.nsk.iae.edtl.Edtl".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	
	//Model:
	//{w} (elements+=Statement)*;
	public ModelElements getModelAccess() {
		return pModel;
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}
	
	//Statement:
	//    DeclVarInput | DeclVarOutput | Abbr | Macros | Requirement;
	public StatementElements getStatementAccess() {
		return pStatement;
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}
	
	//VariableTypeName returns ecore::EString:
	//    'BOOL' | 'INT';
	public VariableTypeNameElements getVariableTypeNameAccess() {
		return pVariableTypeName;
	}
	
	public ParserRule getVariableTypeNameRule() {
		return getVariableTypeNameAccess().getRule();
	}
	
	//DeclVarInput:
	//    {DeclVarInput}
	//    'VAR_INPUT' (value+=VarDeclaration ';')* 'END_VAR';
	public DeclVarInputElements getDeclVarInputAccess() {
		return pDeclVarInput;
	}
	
	public ParserRule getDeclVarInputRule() {
		return getDeclVarInputAccess().getRule();
	}
	
	//DeclVarOutput:
	//    {DeclVarOutput}
	//    'VAR_OUTPUT' (value+=VarDeclaration ';')* 'END_VAR';
	public DeclVarOutputElements getDeclVarOutputAccess() {
		return pDeclVarOutput;
	}
	
	public ParserRule getDeclVarOutputRule() {
		return getDeclVarOutputAccess().getRule();
	}
	
	//VarDeclaration:
	//    var=Variable ':' type=VariableTypeName;
	public VarDeclarationElements getVarDeclarationAccess() {
		return pVarDeclaration;
	}
	
	public ParserRule getVarDeclarationRule() {
		return getVarDeclarationAccess().getRule();
	}
	
	//Abbr:
	//    'ABBR' name=ID
	//        (value+=Expression)*
	//    'END_ABBR';
	public AbbrElements getAbbrAccess() {
		return pAbbr;
	}
	
	public ParserRule getAbbrRule() {
		return getAbbrAccess().getRule();
	}
	
	//Macros:
	//    'MACROS' name=ID '(' (args=VarList)? ')'
	//        (value+=Expression)*
	//    'END_MACROS';
	public MacrosElements getMacrosAccess() {
		return pMacros;
	}
	
	public ParserRule getMacrosRule() {
		return getMacrosAccess().getRule();
	}
	
	//VarList:
	//    vars+=Variable (',' vars+=Variable)*;
	public VarListElements getVarListAccess() {
		return pVarList;
	}
	
	public ParserRule getVarListRule() {
		return getVarListAccess().getRule();
	}
	
	//Requirement:
	//    'REQ' name=ID
	//        (
	//            attribute+=Attribute  DECL_SYMB  value+=Expression ';'
	//        )*
	//    'END_REQ';
	public RequirementElements getRequirementAccess() {
		return pRequirement;
	}
	
	public ParserRule getRequirementRule() {
		return getRequirementAccess().getRule();
	}
	
	//Attribute returns ecore::EString:
	//     'TRIGGER' | 'INV' | 'FINAL' | 'DELAY' | 'REACTION' | 'RELEASE';
	public AttributeElements getAttributeAccess() {
		return pAttribute;
	}
	
	public ParserRule getAttributeRule() {
		return getAttributeAccess().getRule();
	}
	
	////Requirement:
	////    'REQ' '<'reqName=ID'>'
	////        attributes=Attributes
	////    'END_REQ';
	////
	////Attributes returns ecore::EString:
	////     'TRIGGER' DECL_SYMB trig=Expression
	////     'INV' DECL_SYMB inv=Expression
	////     'FINAL' DECL_SYMB fin=Expression
	////     'DELAY' DECL_SYMB del=Expression
	////     'REACTION' DECL_SYMB react=Expression
	////     'RELEASE' DECL_SYMB rel=Expression;
	//terminal DECL_SYMB:
	//    ':=';
	public TerminalRule getDECL_SYMBRule() {
		return tDECL_SYMB;
	}
	
	//Variable:
	//    name=ID;
	public VariableElements getVariableAccess() {
		return pVariable;
	}
	
	public ParserRule getVariableRule() {
		return getVariableAccess().getRule();
	}
	
	//Expression:
	//    XorExpression ({Expression.left=current} orOp=OR_OPERATOR right=XorExpression)*;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//terminal OR_OPERATOR:
	//    '||' | 'OR';
	public TerminalRule getOR_OPERATORRule() {
		return tOR_OPERATOR;
	}
	
	//XorExpression:
	//    AndExpression ({XorExpression.left=current} XOR_OPERATOR right=AndExpression)*;
	public XorExpressionElements getXorExpressionAccess() {
		return pXorExpression;
	}
	
	public ParserRule getXorExpressionRule() {
		return getXorExpressionAccess().getRule();
	}
	
	//XOR_OPERATOR:
	//    'XOR';
	public XOR_OPERATORElements getXOR_OPERATORAccess() {
		return pXOR_OPERATOR;
	}
	
	public ParserRule getXOR_OPERATORRule() {
		return getXOR_OPERATORAccess().getRule();
	}
	
	//AndExpression:
	//    CompExpression ({AndExpression.left=current} andOp=AND_OPERATOR right=CompExpression)*;
	public AndExpressionElements getAndExpressionAccess() {
		return pAndExpression;
	}
	
	public ParserRule getAndExpressionRule() {
		return getAndExpressionAccess().getRule();
	}
	
	//AND_OPERATOR:
	//    '&&' | 'AND';
	public AND_OPERATORElements getAND_OPERATORAccess() {
		return pAND_OPERATOR;
	}
	
	public ParserRule getAND_OPERATORRule() {
		return getAND_OPERATORAccess().getRule();
	}
	
	//CompExpression:
	//    EquExpression ({CompExpression.left=current} compOp=CompOperator right=AndExpression)*;
	public CompExpressionElements getCompExpressionAccess() {
		return pCompExpression;
	}
	
	public ParserRule getCompExpressionRule() {
		return getCompExpressionAccess().getRule();
	}
	
	//EquExpression:
	//    UnExpression ({EquExpression.left=current} equOp=EquOperator right=UnExpression)*;
	public EquExpressionElements getEquExpressionAccess() {
		return pEquExpression;
	}
	
	public ParserRule getEquExpressionRule() {
		return getEquExpressionAccess().getRule();
	}
	
	//enum EquOperator:
	//    EQUAL='==' | NOT_EQUAL='<>';
	public EquOperatorElements getEquOperatorAccess() {
		return eEquOperator;
	}
	
	public EnumRule getEquOperatorRule() {
		return getEquOperatorAccess().getRule();
	}
	
	//enum CompOperator:
	//    LESS='<' | GREATER='>' | LESS_EQU='<=' | GREATER_EQU='>=';
	public CompOperatorElements getCompOperatorAccess() {
		return eCompOperator;
	}
	
	public EnumRule getCompOperatorRule() {
		return getCompOperatorAccess().getRule();
	}
	
	//UnOperator returns ecore::EString:
	//    NotOperator | 'FE' | 'RE' | 'HIGH' | 'LOW' ;
	public UnOperatorElements getUnOperatorAccess() {
		return pUnOperator;
	}
	
	public ParserRule getUnOperatorRule() {
		return getUnOperatorAccess().getRule();
	}
	
	//NotOperator:
	//    'NOT' | '!';
	public NotOperatorElements getNotOperatorAccess() {
		return pNotOperator;
	}
	
	public ParserRule getNotOperatorRule() {
		return getNotOperatorAccess().getRule();
	}
	
	//UnExpression:
	//    PrimaryExpression | unOp=UnOperator right=PrimaryExpression;
	public UnExpressionElements getUnExpressionAccess() {
		return pUnExpression;
	}
	
	public ParserRule getUnExpressionRule() {
		return getUnExpressionAccess().getRule();
	}
	
	//TauExpression:
	//    'TAU' '(' (time=TimeLiteral) ')';
	public TauExpressionElements getTauExpressionAccess() {
		return pTauExpression;
	}
	
	public ParserRule getTauExpressionRule() {
		return getTauExpressionAccess().getRule();
	}
	
	// // | time=Abbr...
	//TimeLiteral:
	//     TIME_PREF_LITERAL interval=INTERVAL;
	public TimeLiteralElements getTimeLiteralAccess() {
		return pTimeLiteral;
	}
	
	public ParserRule getTimeLiteralRule() {
		return getTimeLiteralAccess().getRule();
	}
	
	//TIME_PREF_LITERAL returns ecore::EString:
	//    '#T';
	public TIME_PREF_LITERALElements getTIME_PREF_LITERALAccess() {
		return pTIME_PREF_LITERAL;
	}
	
	public ParserRule getTIME_PREF_LITERALRule() {
		return getTIME_PREF_LITERALAccess().getRule();
	}
	
	//terminal INTERVAL returns ecore::EString:
	//    (INTEGER 'd')? (INTEGER 'h')? (INTEGER 'm')? (INTEGER 's')? (INTEGER 'ms')?;
	public TerminalRule getINTERVALRule() {
		return tINTERVAL;
	}
	
	//PrimaryExpression:
	//    const=INTEGER | var=[CrossVarAbbr] | macros=[Macros]'(' (args=ParamAssignmentElements)? ')'| tau=TauExpression | '(' nestExpr=Expression ')';
	public PrimaryExpressionElements getPrimaryExpressionAccess() {
		return pPrimaryExpression;
	}
	
	public ParserRule getPrimaryExpressionRule() {
		return getPrimaryExpressionAccess().getRule();
	}
	
	//ParamAssignmentElements:
	//    elements+=[Variable] (',' elements+=[Variable])*;
	public ParamAssignmentElementsElements getParamAssignmentElementsAccess() {
		return pParamAssignmentElements;
	}
	
	public ParserRule getParamAssignmentElementsRule() {
		return getParamAssignmentElementsAccess().getRule();
	}
	
	////ParamAssignment:
	////    variable=[Variable] assig=AssignmentType value=Expression;
	//CrossVarAbbr:
	//    Variable | Abbr;
	public CrossVarAbbrElements getCrossVarAbbrAccess() {
		return pCrossVarAbbr;
	}
	
	public ParserRule getCrossVarAbbrRule() {
		return getCrossVarAbbrAccess().getRule();
	}
	
	//terminal INTEGER returns ecore::EString:
	//    DIGIT+;
	public TerminalRule getINTEGERRule() {
		return tINTEGER;
	}
	
	//terminal fragment LETTER:
	//    'A'..'Z' | 'a'..'z' | '_';
	public TerminalRule getLETTERRule() {
		return tLETTER;
	}
	
	//terminal fragment BIT:
	//    '0' | '1';
	public TerminalRule getBITRule() {
		return tBIT;
	}
	
	//terminal fragment OCTAL_DIGIT:
	//    '0'..'7';
	public TerminalRule getOCTAL_DIGITRule() {
		return tOCTAL_DIGIT;
	}
	
	//terminal fragment DIGIT:
	//    '0'..'9';
	public TerminalRule getDIGITRule() {
		return tDIGIT;
	}
	
	//terminal fragment HEX_DIGIT:
	//    DIGIT | 'A'..'F';
	public TerminalRule getHEX_DIGITRule() {
		return tHEX_DIGIT;
	}
	
	//terminal ID returns ecore::EString:
	//    LETTER (LETTER | DIGIT)*;
	public TerminalRule getIDRule() {
		return tID;
	}
	
	//terminal ML_COMMENT:
	//    '/*' -> '*/' | '(*' -> '*)';
	public TerminalRule getML_COMMENTRule() {
		return tML_COMMENT;
	}
	
	//terminal SL_COMMENT:
	//    '//' !('\n'|'\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return tSL_COMMENT;
	}
	
	//terminal WS:
	//    (' '|'\t'|'\r'|'\n')+;
	public TerminalRule getWSRule() {
		return tWS;
	}
}
