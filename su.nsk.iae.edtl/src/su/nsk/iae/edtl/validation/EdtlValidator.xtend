/*
 * generated by Xtext 2.25.0
 */
package su.nsk.iae.edtl.validation

import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.validation.Check
import su.nsk.iae.edtl.edtl.EdtlPackage
import su.nsk.iae.edtl.edtl.Variable
import su.nsk.iae.edtl.edtl.Model

import static extension java.lang.Character.isLowerCase
import static extension java.lang.Character.isUpperCase
import static extension org.eclipse.xtext.EcoreUtil2.*
import su.nsk.iae.edtl.edtl.Expression
import su.nsk.iae.edtl.edtl.AndExpression
import su.nsk.iae.edtl.edtl.UnExpression

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class EdtlValidator extends AbstractEdtlValidator {
	
	val ePackage = EdtlPackage.eINSTANCE

	@Check
	def checkAndOperatorStyle(AndExpression e) {
		if (e.andOp == '&&') {
			warning('please, write AND instead of &&', ePackage.expression_OrOp)
		}
	}
	
	@Check
	def checkOrOperatorStyle(Expression e) {
		if (e.orOp == '||') {
			warning('please, write OR instead of ||', ePackage.expression_OrOp)
		}
	}
	
	@Check
	def checkNotOperatorStyle(UnExpression e) {
		if (e.unOp == '!') {
			warning('please, write NOT instead of !', ePackage.expression_OrOp)
		}
	}
//	
//	private def boolean checkVarRepetition_GlobalVarDeclaration(EList<GlobalVarDeclaration> varList, SymbolicVariable ele) {
//		return varList.stream.anyMatch([x | x.varsSimple.checkVarRepetition_VarInitDeclaration(ele)]) || 
//			   varList.stream.anyMatch([x | x.varsAs.checkVarRepetition_GlobalVarInitDeclaration(ele)])
//	}
//	
//	private def boolean checkNameRepetition(Model model, Variable v) {
//		return model.varInit.checkVarRepetition_GlobalVarDeclaration(v)
//	}
}
